<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>自定義遊戲棋盤</title>
    <style>
        body {
            background-color: #0b0b0b;
            margin: 0;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        /* 拖曳物件樣式 */
        .draggable {
            position: absolute;
            cursor: grab;
            width: 80px; /* 你可以根據需要調整圖片大小 */
            user-select: none;
            -webkit-user-drag: none;
            transition: transform 0.1s;
            z-index: 10;
        }

        .draggable:active {
            cursor: grabbing;
            transform: scale(1.1);
            z-index: 1000;
        }

        /* 棋盤背景（可選） */
        .board-bg {
            position: fixed;
            inset: 0;
            background-image: radial-gradient(circle, #2c3e50 1px, transparent 1px);
            background-size: 50px 50px; /* 點狀背景方便對齊感 */
            z-index: -1;
        }
    </style>
</head>
<body>

    <div class="board-bg"></div>

    <div id="game-container">
        <img src="moba/a_de_1.jpg" class="draggable" style="top: 100px; left: 100px;" draggable="false">
    </div>

    <script>
        // --- 1. 數據定義 (效法你的範例) ---
        // 這樣以後只要把圖片丟進 moba 資料夾，並在這裡增加 ID 即可
        const myImages = [
            { id: 'a_de_1', name: '末日炎魔', path: 'moba/a_de_1.jpg' },
            { id: 'a_de_2', name: '地獄火重砲', path: 'moba/a_de_2.jpg' },
            // 你可以持續增加...
        ];

        const container = document.getElementById('game-container');

        // --- 2. 自動產生圖片物件 ---
        myImages.forEach((imgData, index) => {
            const img = document.createElement('img');
            img.src = imgData.path;
            img.className = 'draggable';
            img.id = imgData.id;
            img.style.left = (100 + index * 100) + 'px'; // 初始排開
            img.style.top = '200px';
            img.setAttribute('draggable', 'false'); // 禁用原生拖曳
            container.appendChild(img);
        });

        // --- 3. 拖曳邏輯 (通用版) ---
        let activeElement = null;
        let offset = { x: 0, y: 0 };

        function startDragging(e) {
            if (e.target.classList.contains('draggable')) {
                activeElement = e.target;
                const clientX = e.clientX ?? e.touches[0].clientX;
                const clientY = e.clientY ?? e.touches[0].clientY;
                
                offset.x = clientX - activeElement.offsetLeft;
                offset.y = clientY - activeElement.offsetTop;
                e.preventDefault();
            }
        }

        function moveDragging(e) {
            if (!activeElement) return;
            const clientX = e.clientX ?? e.touches[0].clientX;
            const clientY = e.clientY ?? e.touches[0].clientY;

            activeElement.style.left = (clientX - offset.x) + 'px';
            activeElement.style.top = (clientY - offset.y) + 'px';
        }

        function stopDragging() {
            activeElement = null;
        }

        // 綁定事件
        document.addEventListener('mousedown', startDragging);
        document.addEventListener('touchstart', startDragging, { passive: false });
        document.addEventListener('mousemove', moveDragging);
        document.addEventListener('touchmove', moveDragging, { passive: false });
        document.addEventListener('mouseup', stopDragging);
        document.addEventListener('touchend', stopDragging);
    </script>
</body>
</html>
